package com.example.demo.service;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.example.demo.dto.PotDTO;
import com.example.demo.dto.ResponsePotDTO;
import com.example.demo.entity.Pot;
import com.example.demo.entity.UpdateDate;
import com.example.demo.entity.User;
import com.example.demo.enums.FilterPeriod;
import com.example.demo.repositories.PotRepository;
import com.example.demo.repositories.UpdateDateRepository;
import com.example.demo.service.exception.ResourceAlreadyExists;
import com.example.demo.service.exception.ResourceNotFoundException;

import jakarta.persistence.criteria.Expression;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.JoinType;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Root;

@Service
public class PotService {

	@Autowired
	private PotRepository potRepository;
	
	@Autowired
	private UpdateDateRepository updateDateRepository;

	public List<UpdateDate> listUpdates(
			UUID id, 
			FilterPeriod period) {
		
		if (id == null) {
			throw new ResourceNotFoundException("id cannot be null");
		}
		
		 Specification<UpdateDate> spec = (root, query, cb) -> {
	            Join<UpdateDate, Pot> potJoin = root.join("pot", JoinType.INNER);
	            
	            Predicate periodoPredicate = null;
	            if (period != null && period != FilterPeriod.ALL) {
	                Expression<Instant> dataExpression = root.get("date");
	                
	                switch (period) {
	                    case LAST_MONTH:
	                        return cb.between(dataExpression, 
	                            Instant.now().minus(30, ChronoUnit.DAYS),
	                            Instant.now());
	                        
	                    case LAST_6_MONTHS:
	                        return cb.between(dataExpression,
	                            Instant.now().minus(183, ChronoUnit.DAYS),
	                            Instant.now());
	                        
	                    case LAST_YEAR:
	                        return cb.between(dataExpression,
	                            Instant.now().minus(365, ChronoUnit.DAYS),
	                            Instant.now());
	                        
	                    default:
	                        return cb.conjunction();
	                }
	            }
	            
	            return cb.equal(potJoin.get("id"), id);
	        };
	        
	        return updateDateRepository.findAll(spec);
	
	}
	

	@Transactional
	public Pot newPot(User user, PotDTO data) {

		boolean existPot = user.getPots().stream().anyMatch(obj -> obj.getTitle().equals(data.title()));

		if (existPot) {
			throw new ResourceAlreadyExists("pot already exists in list");
		}

		Pot pot = new Pot(null, data.title(), data.description(), data.monthlyAmount(), data.color(),
				new ArrayList<>());

		UpdateDate update = new UpdateDate(null, Instant.now(), data.monthlyAmount());
		update.setPot(pot);
		pot.getUpdate().add(update);

		pot.setUser(user);

		Pot response = potRepository.save(pot);
		user.getPots().add(response);

		return response;
	}

	public ResponsePotDTO getIdPot(UUID id) {

		if (id == null) {
			throw new ResourceNotFoundException("id cannot be null");
		}

		Optional<Pot> potOptional = potRepository.findById(id);
		Pot pot = potOptional.orElseThrow(() -> new ResourceNotFoundException("pot not found"));
		
		Optional<UpdateDate> lastUpdateOptional = updateDateRepository.findLatestUpdate(pot);
		UpdateDate lastUpdate = lastUpdateOptional.orElseThrow(); // voltar aqui
		
		ResponsePotDTO response = new ResponsePotDTO(
				pot.getTitle(),
				pot.getDescription(),
				pot.getMonthlyAmount(),
				lastUpdate.getDate()
				);

		return response;
	}

	public Pot editPot(PotDTO data, UUID id) {

		Optional<Pot> requestOptional = this.potRepository.findById(id);

		Pot request = requestOptional.orElseThrow(() -> new ResourceNotFoundException("pot not found"));

		if (!data.monthlyAmount().equals(request.getMonthlyAmount()) && data.monthlyAmount() != null) {

			UpdateDate update = new UpdateDate(null, Instant.now(), data.monthlyAmount());
			update.setPot(request);
			request.getUpdate().add(update);

			request.setMonthlyAmount(data.monthlyAmount());
		}

		String title = data.title() == null && data.title().equals("") ? request.getTitle() : data.title();

		String description = data.description() == null || data.description().equals("") ? request.getTitle()
				: data.title();

		String color = data.color() == null || data.color().equals("") ? request.getColor() : data.color();

		request.setTitle(title);
		request.setDescription(description);
		request.setColor(color);

		Pot response = this.potRepository.save(request);

		return response;
	}

	public void deletePot(UUID id) {

		try {

			Optional<Pot> requestOptional = potRepository.findById(id);
			Pot request = requestOptional.orElseThrow(() -> new ResourceNotFoundException("pot not found"));

			potRepository.delete(request);

		} catch (Exception e) {

			throw new ResourceNotFoundException("An unexpected error occurred while deleting pot");
		}

	}

}
